<!-- sectionTitle: 2. Consider all the parameters -->
<!-- note
- Now that we have a goal lets take a look at how we can create the best possible tests

- and the very first thing we should do is to understand the API we are testing and all of its parameters
-->
### üîò
## 2. Consider all the parameters

---
<!-- note
- So what I have here is the http request we would send for an user to submit an order on to the exchange

- We can see that in the json payload, it has a few different fields which we can send. Like symbol, side, order type, quantity and price.

- If we were to send this request over and over, while the test is valid, I would argue its not exactly testing the system as whole. Because we would be constantly sending a buy order with no sell orders which means that apart from testing order submission no other part of the system is being exercised.

- You have no idea how many times I have seen people use the same request to perform performance testing and call it done. 

- ITS A HUGE NO NO
-->
## üôÅ

```http request
POST https://{{host}}/api/order
jwt: abcdefg1234567890
Content-Type: application/json
Accept: application/json
Accept-Charset: utf-8

{
    "symbol": "EthBtc",
    "side": "Buy",
    "order_type": "Limit",
    "time_in_force": "Gtc",
    "quantity": 2,
    "price": 10.3123,
    "new_order_resp_type": "Ack",
    "timestamp": 1562336244
}
```

---
<!-- note
- Now lets take another look at the fields in the json payload and the values it accepts, 

- we can see that apart from the price and quantity which we can send any value we want. 

- There are also side which determine whether it is a buy or a sell order

- The type of order. the symbol or the cryptocurrency your trading and the time in force, whether its Good till cancel or Immediate or cancel.

-->
## Parameters

```scala
val price = ??
val quantity = ??

val Side = Array("Buy", "Sell")
val OrderTypes = Array("Market", "Limit", "StopLoss", "StopLossLimit", "TakeProfit", "TakeProfitLimit", "LimitMaker")
val TimeInForce = Array("Gtc", "Ioc")
val Symbols = Array("EthBtc", "EthLtc", "EthUsdt", "EthXrp")
```

---
<!-- note
- So just from looking at the different values the json payload accepts we start to notice there are a few permuation of orders we can submit 

- Here is a just a small code snippet where I paramaterized the test so I can start to feed those values into the request
-->
```scala
exec(http("""POST /api/order STOPLOSS SELL ${symbol}""")
  .post("/order")
  .body(StringBody(
    """{
               "symbol": "${symbol}",
               "side": "${side}",
               "order_type": "StopLoss",
               "time_in_force": "Gtc",
               "quantity": ${quantity},
               "stop_price": ${stopSellPrice},
               "new_order_resp_type": "Ack",
               "timestamp": ${timestamp}
               }""")).asJson
  .headers(PostHeaders)
  .header("jwt", """${jwt}""")
  .check(status.is(200))
)
```

---
<!--note
- So now we are looking at the feeder or the parameter generator

- in this iteration I have just kept it very simple where I randomly generated them.

- While this works much better than sending the same request over and over, it still has shortcomings 

- since the price is randomly generated, the likelihood of a price matching is very low which means we are not exercising the entire system as much as we would like. So we can definitely do better.
-->
## üòï

```scala
val orderParams: Iterator[Map[String, Any]] = Iterator.continually(
  Map(
    "quantity" -> Random.nextDouble() * 100,
    "price" -> Random.nextDouble() * 10,
    "symbol" -> Symbols(Random.nextInt(Symbols.length)),
    "timestamp" -> Instant.now.getEpochSecond,
  )
)
```

--- 
<!--note
- And what I did was I made a function to grab the market price from cache 

- There is a separate thread in the background that constantly pulls the price down from a public API for the test to use.

- Then a buy and a sell price gets generated with a small randomness factor and gets inserted into the payload based on the side

- This significantly improved the number of orders being matched in my test as the market would fluctuate and now I am comfortable with how the actual tests would run
-->
## üòÉ

```scala
val orderParams: Iterator[Map[String, Any]] = Iterator.continually(
    elem = {
        val symbol = Random.nextInt(Symbols.length)
        val marketPrice = getMarketPrice(symbol)
        Map(
            "quantity" -> Random.nextDouble() * 100,
            "price" -> marketPrice,
            "sellPrice" -> marketPrice * (1 + (Random.nextInt(5) / 1000)),
            "buyPrice" -> marketPrice * (1 - (Random.nextInt(5) / 1000)),
            "symbol" -> Symbols(symbol),
            "timestamp" -> Instant.now.getEpochSecond,
        )
    }
)
```
